<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Space Invaders Balanced (Optimized)</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      text-align: center;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: radial-gradient(circle at center, #001, #000);
    }
    h1 { color: #0ff; text-shadow: 0 0 10px #0ff; }
    #scoreBoard, #healthDisplay { font-size: 24px; margin-top: 10px; }
    #endScreen {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      text-align: center;
    }
    #endScreen button {
      font-size: 20px;
      padding: 10px 20px;
      margin-top: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="scoreBoard">Score: 0</div>
  <div id="healthDisplay">Health: 3</div>
  <div id="endScreen">
    <h1 id="finalScore">Game Over! Score: 0</h1>
    <button id="playAgain">Play Again</button>
  </div>
  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <script>
  (function () {
    // DOM
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const healthDisplay = document.getElementById('healthDisplay');
    const endScreen = document.getElementById('endScreen');
    const finalScore = document.getElementById('finalScore');
    const playAgain = document.getElementById('playAgain');

    // Constants (pixels per second)
    const PLAYER_SPEED = 360;
    const BULLET_SPEED = 700;
    const ENEMY_BULLET_SPEED = 220;
    const ENEMY_SPEED = 40;
    const ENEMY_ROWS = 5;
    const ENEMY_COLS = 6;
    const ENEMY_X_GAP = 80;
    const ENEMY_Y_GAP = 50;
    const ENEMY_START_X = 60;
    const ENEMY_START_Y = 50;
    const ENEMY_WIDTH = 40;
    const ENEMY_HEIGHT = 20;
    const ENEMY_SHIFT_DOWN = 20;
    const PLAYER_FIRE_COOLDOWN = 200; // ms
    const ENEMY_SHOT_MIN = 800; // ms
    const ENEMY_SHOT_MAX = 4000; // ms

    // State
    let score = 0;
    let health = 3;
    let gameRunning = true;

    const player = {
      x: 270, y: 550, width: 60, height: 20,
      speed: PLAYER_SPEED,
      lastFire: 0
    };

    // Arrays
    const bullets = [];        // upward bullets (active objects)
    const enemyBullets = [];   // downward bullets
    let enemies = [];          // enemy objects

    // Controls
    const keys = {};

    // Cached size
    const CANVAS_W = canvas.width;
    const CANVAS_H = canvas.height;

    // Utilities
    function removeAtSwap(arr, i) {
      const last = arr.length - 1;
      if (i !== last) arr[i] = arr[last];
      arr.pop();
    }
    function randBetween(min, max) { return Math.random() * (max - min) + min; }
    function nowMs() { return performance.now(); }

    // Enemy creation with deterministic layout and small jitter
    function createEnemies() {
      enemies.length = 0;
      const colors = ['#f00','#0f0','#00f','#a0f','#fa0','#0ff','#f0a','#ff0'];
      for (let r = 0; r < ENEMY_ROWS; r++) {
        for (let c = 0; c < ENEMY_COLS; c++) {
          const jitterX = randBetween(-5, 5);
          const jitterY = randBetween(-5, 5);
          enemies.push({
            x: ENEMY_START_X + c * ENEMY_X_GAP + jitterX,
            y: ENEMY_START_Y + r * ENEMY_Y_GAP + jitterY,
            width: ENEMY_WIDTH,
            height: ENEMY_HEIGHT,
            color: colors[(r * ENEMY_COLS + c) % colors.length],
            hp: 1,
            alive: true,
            nextShot: nowMs() + randBetween(ENEMY_SHOT_MIN, ENEMY_SHOT_MAX)
          });
        }
      }
      enemyDirection = 1;
    }

    // Game variables
    let enemyDirection = 1; // 1:right, -1:left

    // Initialize
    createEnemies();
    scoreBoard.textContent = 'Score: ' + score;
    healthDisplay.textContent = 'Health: ' + health;

    // Draw helpers
    function drawRect(obj, fill, stroke) {
      ctx.fillStyle = fill;
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
      if (stroke) {
        ctx.strokeStyle = stroke;
        ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
      }
    }

    // Collision AABB
    function intersects(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // Input
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.code === 'Space') {
        e.preventDefault(); // prevent page scroll
        const t = nowMs();
        if (t - player.lastFire >= PLAYER_FIRE_COOLDOWN && gameRunning) {
          player.lastFire = t;
          bullets.push({
            x: player.x + player.width / 2 - 5,
            y: player.y - 20,
            width: 10, height: 20, speed: BULLET_SPEED
          });
        }
      }
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    playAgain.addEventListener('click', () => {
      // reset
      score = 0;
      health = 3;
      gameRunning = true;
      bullets.length = 0;
      enemyBullets.length = 0;
      createEnemies();
      scoreBoard.textContent = 'Score: ' + score;
      healthDisplay.textContent = 'Health: ' + health;
      endScreen.style.display = 'none';
      lastTime = 0;
      requestAnimationFrame(loop);
    });

    // Game loop (delta time)
    let lastTime = 0;
    function loop(timestamp) {
      if (!gameRunning) return;
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;

      // Clear
      ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

      // Player movement
      const left = keys['a'] || keys['ArrowLeft'];
      const right = keys['d'] || keys['ArrowRight'];
      if (left) player.x -= player.speed * dt;
      if (right) player.x += player.speed * dt;
      // clamp
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > CANVAS_W) player.x = CANVAS_W - player.width;

      // Draw player
      drawRect(player, '#0f0');

      // Update bullets (swap-pop removals)
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y -= b.speed * dt;
        drawRect(b, '#ff0');
        if (b.y + b.height < 0) removeAtSwap(bullets, i);
      }

      // Move enemies - compute alive bounds once
      let minX = Infinity, maxX = -Infinity, anyAlive = false;
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        if (!e.alive) continue;
        anyAlive = true;
        if (e.x < minX) minX = e.x;
        if (e.x + e.width > maxX) maxX = e.x + e.width;
      }

      // Decide direction and shift if needed
      const projectedLeft = minX + enemyDirection * ENEMY_SPEED * dt;
      const projectedRight = maxX + enemyDirection * ENEMY_SPEED * dt;
      if (projectedLeft < 0 || projectedRight > CANVAS_W) {
        enemyDirection *= -1;
        // shift down
        for (let i = 0; i < enemies.length; i++) {
          const e = enemies[i];
          if (e.alive) e.y += ENEMY_SHIFT_DOWN;
        }
      } else {
        // apply horizontal movement
        for (let i = 0; i < enemies.length; i++) {
          const e = enemies[i];
          if (e.alive) e.x += enemyDirection * ENEMY_SPEED * dt;
        }
      }

      // Draw enemies and possibly shoot
      const tNow = nowMs();
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        if (!e.alive) continue;
        drawRect(e, e.color, '#fff');

        // Enemy shooting based on scheduled time
        if (tNow >= e.nextShot) {
          enemyBullets.push({
            x: e.x + e.width / 2 - 3,
            y: e.y + e.height,
            width: 6, height: 15, speed: ENEMY_BULLET_SPEED
          });
          e.nextShot = tNow + randBetween(ENEMY_SHOT_MIN, ENEMY_SHOT_MAX);
        }

        // Direct collision with player
        if (e.y + e.height >= player.y &&
            e.y <= player.y + player.height &&
            e.x + e.width >= player.x &&
            e.x <= player.x + player.width) {
          // enemy hits player
          e.alive = false;
          health--;
          if (health <= 0) {
            health = 0;
            endGame();
            return;
          }
        }
      }

      // Enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.y += b.speed * dt;
        drawRect(b, '#0ff');
        if (b.y > CANVAS_H) {
          removeAtSwap(enemyBullets, i);
          continue;
        }
        if (intersects(b, player)) {
          removeAtSwap(enemyBullets, i);
          health--;
          if (health <= 0) {
            health = 0;
            endGame();
            return;
          }
        }
      }

      // Bullet-to-enemy collisions: iterate bullets and test against enemies
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        let hit = false;
        for (let j = 0; j < enemies.length; j++) {
          const e = enemies[j];
          if (!e.alive) continue;
          if (intersects(b, e)) {
            // remove bullet (swap-pop) and mark enemy
            removeAtSwap(bullets, i);
            e.hp--;
            if (e.hp <= 0) {
              e.alive = false;
              score++;
            }
            hit = true;
            break;
          }
        }
        if (hit) continue;
      }

      // Update DOM only when changed
      scoreBoard.textContent = 'Score: ' + score;
      healthDisplay.textContent = 'Health: ' + health;

      // Respawn if all dead
      if (!anyAlive) createEnemies();

      requestAnimationFrame(loop);
    }

    function endGame() {
      gameRunning = false;
      finalScore.textContent = 'Game Over! Score: ' + score;
      endScreen.style.display = 'block';
    }

    // Start loop
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
